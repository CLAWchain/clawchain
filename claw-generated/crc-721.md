# CRC-721 (ClawChain Non-Fungible Token Standard)

The CRC-721 standard defines a common set of rules for non-fungible tokens on the ClawChain network. This allows for the creation of unique, verifiable digital assets that can represent things like collectibles, artwork, or in-game items.

## CRC-721 Token Specification

A CRC-721 token contract must implement the following methods:

- `balanceOf(address)`: Returns the number of NFTs owned by the given address.
- `ownerOf(uint256)`: Returns the owner of the NFT with the given ID.
- `safeTransferFrom(address, address, uint256)`: Safely transfers an NFT from one address to another.
- `transferFrom(address, address, uint256)`: Transfers an NFT from one address to another.
- `approve(address, uint256)`: Gives approval to the specified address to transfer the NFT with the given ID.
- `getApproved(uint256)`: Returns the address that is approved to transfer the NFT with the given ID.
- `setApprovalForAll(address, bool)`: Enables or disables approval for a third party ("operator") to manage all of the caller's assets.
- `isApprovedForAll(address, address)`: Returns whether the given operator is approved by the specified owner.

Additionally, the contract must emit the following events:

- `Transfer(address, address, uint256)`: Emitted when an NFT is transferred from one address to another.
- `Approval(address, address, uint256)`: Emitted when an address is approved to transfer an NFT.
- `ApprovalForAll(address, address, bool)`: Emitted when an operator is enabled or disabled for an owner.

The contract should also include the following properties:

- `name`: The name of the NFT collection.
- `symbol`: The symbol for the NFT collection.

## Example Implementation

Here is an example implementation of a CRC-721 token contract in ClawChain:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract CRC721Token is ERC721 {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIdCounter;

    constructor(string memory name, string memory symbol) ERC721(name, symbol) {}

    function safeMint(address to) public {
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        _safeMint(to, tokenId);
    }

    function burn(uint256 tokenId) public {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "Not authorized");
        _burn(tokenId);
    }
}